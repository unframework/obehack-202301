// IKEA Obegraensad sketch 2023-01

#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <WiFiUdp.h>

const char *ssid = "********";
const char *password = "********";
const char *mDNSDomain = "esp8266";

WiFiUDP UDP;
unsigned int localUDPPort = 7007; // local port to listen on

char renderBuffer[256]; // pixel buffer, only lowest 3 bits should be used

// ESP8266 Feather pinout
#define LEDARRAY_CLA 4
#define LEDARRAY_CLK 5
#define LEDARRAY_DI 2
#define LEDARRAY_EN 16

#define MASK_CLA (1 << LEDARRAY_CLA)
#define MASK_CLK (1 << LEDARRAY_CLK)
#define MASK_DI (1 << LEDARRAY_DI)

#define ROWS 16
#define COLS 16

// ticks at TIM_DIV16 setting (16 * 1us / 80 = 0.2us)
#if defined(F_CPU) && (F_CPU == 160000000L)
// faster timer for 160Mhz
#define TIMER1_TICKS 500
#else
// lower than this and WDT gets triggered
#define TIMER1_TICKS 700
#endif

// actual LED layout corresponding to the shift register queue is complex and
// snaking, this is the LUT
// see https://github.com/atesgoral/obegraensad-hack/blob/main/src/main.cpp#L41
const unsigned char positions[ROWS * COLS] = {
    // clang-format off
    0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x2f, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4a, 0x49, 0x48, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    0x6f, 0x6e, 0x6d, 0x6c, 0x6b, 0x6a, 0x69, 0x68, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    0x87, 0x86, 0x85, 0x84, 0x83, 0x82, 0x81, 0x80, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0xa7, 0xa6, 0xa5, 0xa4, 0xa3, 0xa2, 0xa1, 0xa0, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
    0xaf, 0xae, 0xad, 0xac, 0xab, 0xaa, 0xa9, 0xa8, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    0xcf, 0xce, 0xcd, 0xcc, 0xcb, 0xca, 0xc9, 0xc8, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    0xc7, 0xc6, 0xc5, 0xc4, 0xc3, 0xc2, 0xc1, 0xc0, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
    0xe7, 0xe6, 0xe5, 0xe4, 0xe3, 0xe2, 0xe1, 0xe0, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    0xef, 0xee, 0xed, 0xec, 0xeb, 0xea, 0xe9, 0xe8, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
    // clang-format on
};

unsigned int pwmFrame = 0;

// per brightness level, how many frames are on out of a 64-frame full duty
// cycle (note that the progression is very non-linear)
// full length is 256 to avoid weird memory access in case of over-limit pixel
// values
unsigned int pwmDutyCounts[256] = {0, 1, 3, 8, 14, 27, 36, 64};

#define RDR_UPDATE_DATA(cond) if(cond){GPOS=MASK_DI;}else{GPOC=MASK_DI;}
#define RDR_TOGGLE_CLK GPOS=MASK_CLK;GPOC=MASK_CLK;
#define RDR_RUN_PIXEL(pos) RDR_UPDATE_DATA(frameDuty < pwmDutyCounts[renderBuffer[static_cast<unsigned char>(pos)]]) RDR_TOGGLE_CLK

#define RDR_ALL_POSITIONS(run) \
  run(0x0f) run(0x0e) run(0x0d) run(0x0c) run(0x0b) run(0x0a) run(0x09) run(0x08) run(0x18) run(0x19) run(0x1a) run(0x1b) run(0x1c) run(0x1d) run(0x1e) run(0x1f) \
  run(0x07) run(0x06) run(0x05) run(0x04) run(0x03) run(0x02) run(0x01) run(0x00) run(0x10) run(0x11) run(0x12) run(0x13) run(0x14) run(0x15) run(0x16) run(0x17) \
  run(0x27) run(0x26) run(0x25) run(0x24) run(0x23) run(0x22) run(0x21) run(0x20) run(0x30) run(0x31) run(0x32) run(0x33) run(0x34) run(0x35) run(0x36) run(0x37) \
  run(0x2f) run(0x2e) run(0x2d) run(0x2c) run(0x2b) run(0x2a) run(0x29) run(0x28) run(0x38) run(0x39) run(0x3a) run(0x3b) run(0x3c) run(0x3d) run(0x3e) run(0x3f) \
  run(0x4f) run(0x4e) run(0x4d) run(0x4c) run(0x4b) run(0x4a) run(0x49) run(0x48) run(0x58) run(0x59) run(0x5a) run(0x5b) run(0x5c) run(0x5d) run(0x5e) run(0x5f) \
  run(0x47) run(0x46) run(0x45) run(0x44) run(0x43) run(0x42) run(0x41) run(0x40) run(0x50) run(0x51) run(0x52) run(0x53) run(0x54) run(0x55) run(0x56) run(0x57) \
  run(0x67) run(0x66) run(0x65) run(0x64) run(0x63) run(0x62) run(0x61) run(0x60) run(0x70) run(0x71) run(0x72) run(0x73) run(0x74) run(0x75) run(0x76) run(0x77) \
  run(0x6f) run(0x6e) run(0x6d) run(0x6c) run(0x6b) run(0x6a) run(0x69) run(0x68) run(0x78) run(0x79) run(0x7a) run(0x7b) run(0x7c) run(0x7d) run(0x7e) run(0x7f) \
  run(0x8f) run(0x8e) run(0x8d) run(0x8c) run(0x8b) run(0x8a) run(0x89) run(0x88) run(0x98) run(0x99) run(0x9a) run(0x9b) run(0x9c) run(0x9d) run(0x9e) run(0x9f) \
  run(0x87) run(0x86) run(0x85) run(0x84) run(0x83) run(0x82) run(0x81) run(0x80) run(0x90) run(0x91) run(0x92) run(0x93) run(0x94) run(0x95) run(0x96) run(0x97) \
  run(0xa7) run(0xa6) run(0xa5) run(0xa4) run(0xa3) run(0xa2) run(0xa1) run(0xa0) run(0xb0) run(0xb1) run(0xb2) run(0xb3) run(0xb4) run(0xb5) run(0xb6) run(0xb7) \
  run(0xaf) run(0xae) run(0xad) run(0xac) run(0xab) run(0xaa) run(0xa9) run(0xa8) run(0xb8) run(0xb9) run(0xba) run(0xbb) run(0xbc) run(0xbd) run(0xbe) run(0xbf) \
  run(0xcf) run(0xce) run(0xcd) run(0xcc) run(0xcb) run(0xca) run(0xc9) run(0xc8) run(0xd8) run(0xd9) run(0xda) run(0xdb) run(0xdc) run(0xdd) run(0xde) run(0xdf) \
  run(0xc7) run(0xc6) run(0xc5) run(0xc4) run(0xc3) run(0xc2) run(0xc1) run(0xc0) run(0xd0) run(0xd1) run(0xd2) run(0xd3) run(0xd4) run(0xd5) run(0xd6) run(0xd7) \
  run(0xe7) run(0xe6) run(0xe5) run(0xe4) run(0xe3) run(0xe2) run(0xe1) run(0xe0) run(0xf0) run(0xf1) run(0xf2) run(0xf3) run(0xf4) run(0xf5) run(0xf6) run(0xf7) \
  run(0xef) run(0xee) run(0xed) run(0xec) run(0xeb) run(0xea) run(0xe9) run(0xe8) run(0xf8) run(0xf9) run(0xfa) run(0xfb) run(0xfc) run(0xfd) run(0xfe) run(0xff) \

void ICACHE_RAM_ATTR onTimerISR() {
  // start countdown again right away to keep timing consistent
  // @todo check for deadlock if frame takes too long?
  timer1_write(TIMER1_TICKS);

  // render the frame
  const int frameDuty = pwmFrame & 63;

  /*
  for (int idx = 0; idx < ROWS * COLS; idx++) {
    const unsigned char pos = positions[idx];
    RDR_RUN_PIXEL(pos)
  }
  */
  RDR_ALL_POSITIONS(RDR_RUN_PIXEL)

  GPOS = MASK_CLA; // fast direct write set
  GPOC = MASK_CLA; // fast direct write clear

  pwmFrame += 1;
}

void setup() {
  // turn on 160Mhz for fun and profit! that is, a smoother PWM
  #if defined(F_CPU) && (F_CPU == 160000000L)
  system_update_cpu_freq(160);
  // REG_SET_BIT(0x3ff00014, BIT(0));
  // ets_update_cpu_frequency(160);
  #endif

  // test pattern
  for (int pixel = 0; pixel < ROWS * COLS; pixel++) {
    const int col = pixel & 15;
    const int row = pixel >> 4;

    const unsigned char gradient = (col >> 1); // reduce to a 3-bit value
    const unsigned char value =
        (col + row) & 1 ? (row & 1 ? 7 - gradient : gradient) : 0;

    renderBuffer[pixel] = value;
  }

  // LED panel
  pinMode(LEDARRAY_CLA, OUTPUT);
  pinMode(LEDARRAY_CLK, OUTPUT);
  pinMode(LEDARRAY_DI, OUTPUT);
  pinMode(LEDARRAY_EN, OUTPUT);

  // initial state
  digitalWrite(LEDARRAY_CLA, LOW);
  digitalWrite(LEDARRAY_CLK, LOW);
  digitalWrite(LEDARRAY_DI, LOW);

  // turn on display
  digitalWrite(LEDARRAY_EN, LOW);

  // setup render loop
  timer1_attachInterrupt(onTimerISR);
  timer1_enable(TIM_DIV16, TIM_EDGE,
                TIM_SINGLE); // restarted inside frameloop itself
  timer1_write(TIMER1_TICKS);

  // proceed with other initialization
  Serial.begin(115200);
  Serial.println();

  Serial.printf("Connecting to %s ", ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println(" connected");

  UDP.begin(localUDPPort);
  Serial.printf("Now listening at IP %s, UDP port %d\n",
                WiFi.localIP().toString().c_str(), localUDPPort);

  if (!MDNS.begin(mDNSDomain)) {
    Serial.println("Error setting up MDNS responder!");
  } else {
    Serial.println("mDNS responder started");
  }
}

void loop() {
  // receive incoming UDP packet
  // @todo move to another core
  const int packetSize = UDP.parsePacket();

  if (packetSize) {
    const int len = UDP.read(renderBuffer, 256);
    for (int i = 0; i < len; i++) {
      renderBuffer[i] >>= 5; // reduce to a 3-bit value
    }
  }
}
